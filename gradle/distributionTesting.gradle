/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.gradle.testing.DistributionTest

tasks.withType(DistributionTest) { DistributionTest task ->

    dependsOn(":toolingApi:toolingApiShadedJar")
    dependsOn(":cleanUpCaches")
    finalizedBy(":cleanUpDaemons")
    shouldRunAfter("test")

    jvmArgs("-Xmx512m", "-XX:+HeapDumpOnOutOfMemoryError")
    if (!javaVersion.java8Compatible) {
        jvmArgs("-XX:MaxPermSize=768m")

    }

    def javaConvention = project.convention.getPlugin(JavaPluginConvention)
    reports.junitXml.destination = new File(javaConvention.testResultsDir, name)

    // use -PtestVersions=all or -PtestVersions=1.2,1.3â€¦
    if (project.hasProperty("testVersions")) {
        systemProperties["org.gradle.integtest.versions"] = project.testVersions
    }
    if (!systemProperties["org.gradle.integtest.versions"]) {
        systemProperties["org.gradle.integtest.versions"] = "latest"
    }

    systemProperties["org.gradle.integtest.cpp.toolChains"] =
        project.hasProperty("testAllPlatforms") && project.testAllPlatforms ? "all" : "default"

    systemProperties["org.gradle.integtest.multiversion"] =
        project.hasProperty("testAllVersions") && project.testAllVersions ? "all" : "default"

    def mirrorUrls = collectMirrorUrls()
    def mirrors = ["mavencentral", "jcenter", "lightbendmaven", "ligthbendivy", "google"]
    mirrors.each { mirror ->
        systemProperties["org.gradle.integtest.mirrors.$mirror"] = mirrorUrls[mirror] ?: ""
    }

    dependsOn project.task("configure${task.name.capitalize()}") {
        doLast {
            configure(task) {

                ReportingExtension reporting = project.reporting
                reports.html.destination = file("${reporting.baseDir}/$name")

                Sync intTestImage = project.intTestImage
                gradleHomeDir = intTestImage.destinationDir

                gradleUserHomeDir = rootProject.file("intTestHomeDir")

                Zip toolingApiShadedJar = rootProject.project(":toolingApi").toolingApiShadedJar
                toolingApiShadedJarDir = toolingApiShadedJar.destinationDir

                if (requiresLibsRepo) {
                    libsRepo = rootProject.file("build/repo")
                }
                if (requiresDists) {
                    def base = rootProject.convention.getPlugin(BasePluginConvention)
                    distsDir = base.distsDir
                    systemProperties["integTest.distZipVersion"] = version
                }
                if (requiresBinZip) {
                    Zip binZipDistribution = project(":distributions").binZip
                    binZip = binZipDistribution.archivePath
                }
                daemonRegistry = file("$rootProject.buildDir/daemon")
            }
        }
    }

    def daemonListener = null

    doFirst {
        daemonListener = rootProject.cleanUpDaemons.newDaemonListener()
        gradle.addListener(daemonListener)
    }

    doLast {
        gradle.removeListener(daemonListener)
    }
}

project(":") {

    if (tasks.findByName("cleanUpCaches")) {
        return
    }

    task cleanUpCaches(type: org.gradle.cleanup.CleanUpCaches) {
        dependsOn(":createBuildReceipt")
    }

    task cleanUpDaemons(type: org.gradle.cleanup.CleanUpDaemons)

    task killExistingProcessesStartedByGradle(type: org.gradle.process.KillLeakingJavaProcesses)

    if (isCiServer) {
        clean.dependsOn(killExistingProcessesStartedByGradle)
        subprojects {
            tasks.all {
                mustRunAfter(killExistingProcessesStartedByGradle)
            }
        }
    }
}

def collectMirrorUrls() {
    // expected env var format: repo1_id:repo1_url,repo2_id:repo2_url,...
    System.getenv("REPO_MIRROR_URLS")?.split(",")?.collectEntries { nameToUrl ->
        def index = nameToUrl.indexOf(":")
        [(nameToUrl.substring(0, index)) : nameToUrl.substring(index + 1)]
    } ?: [:]
}

