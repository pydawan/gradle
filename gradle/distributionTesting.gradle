/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.gradle.testing.DistributionTest

tasks.withType(DistributionTest) { DistributionTest task ->

    dependsOn ':toolingApi:toolingApiShadedJar'
    dependsOn ':cleanUpCaches'
    finalizedBy ':cleanUpDaemons'
    shouldRunAfter 'test'

    jvmArgs '-Xmx512m', '-XX:+HeapDumpOnOutOfMemoryError'
    if (!javaVersion.java8Compatible) {
        jvmArgs '-XX:MaxPermSize=768m'

    }

    reports.junitXml.destination = new File(project.testResultsDir, name)

    // use -PtestVersions=all or -PtestVersions=1.2,1.3â€¦
    if (project.hasProperty('testVersions')) {
        systemProperties['org.gradle.integtest.versions'] = project.testVersions
    }
    if (!systemProperties['org.gradle.integtest.versions']) {
        systemProperties['org.gradle.integtest.versions'] = 'latest'
    }

    systemProperties['org.gradle.integtest.cpp.toolChains'] = project.hasProperty("testAllPlatforms") && project.testAllPlatforms ? 'all' : 'default'

    systemProperties['org.gradle.integtest.multiversion'] = project.hasProperty("testAllVersions") && project.testAllVersions ? 'all' : 'default'

    def mirrorUrls = collectMirrorUrls()
    def mirrors = ['mavencentral', 'jcenter', 'lightbendmaven', 'ligthbendivy', 'google']
    mirrors.each { mirror ->
        systemProperties["org.gradle.integtest.mirrors.$mirror"] = mirrorUrls[mirror] ?: ''
    }

    dependsOn project.task("configure${task.name.capitalize()}") {
        doLast {
            configure(task) {
                reports.html.destination = file("${project.reporting.baseDir}/$name")
                gradleHomeDir = intTestImage.destinationDir
                gradleUserHomeDir = rootProject.file('intTestHomeDir')
                toolingApiShadedJarDir = rootProject.project(':toolingApi').toolingApiShadedJar.destinationDir

                if (requiresLibsRepo) {
                    libsRepo = rootProject.file('build/repo')
                }
                if (requiresDists) {
                    distsDir = rootProject.distsDir
                    systemProperties['integTest.distZipVersion'] = version
                }
                if (requiresBinZip) {
                    binZip = project(':distributions').binZip.archivePath
                }
                daemonRegistry = file("$rootProject.buildDir/daemon")
            }
        }
    }

    ext.daemonListener = null

    doFirst {
        daemonListener = rootProject.cleanUpDaemons.newDaemonListener()
        gradle.addListener(daemonListener)
    }

    doLast {
        gradle.removeListener(daemonListener)
    }
}

def collectMirrorUrls() {
    // expected env var format: repo1_id:repo1_url,repo2_id:repo2_url,...
    System.getenv('REPO_MIRROR_URLS')?.split(',')?.collectEntries { nameToUrl ->
        def index = nameToUrl.indexOf(':')
        [(nameToUrl.substring(0, index)) : nameToUrl.substring(index + 1)]
    } ?: [:]
}

project(":") {
    if (tasks.findByName('cleanUpCaches')) {
        return
    }

    task cleanUpCaches(type: org.gradle.cleanup.CleanUpCaches) {
        dependsOn ':createBuildReceipt'
    }
}

def forEachJavaProcess(Closure action) {
    org.gradle.process.Process.forEachLeakingJavaProcess(project, { action.call(it.pid, it.process) } as Action)
}

def pkill(pid) {
    org.gradle.process.Process.pkill(project, pid)
}

project(":") {

    if (tasks.findByName('cleanUpDaemons')) {
        return
    }

    task cleanUpDaemons(type: org.gradle.cleanup.CleanUpDaemons)

    task killExistingProcessesStartedByGradle {
        doLast {
            def didKill = false
            forEachJavaProcess { pid, process ->
                logger.warn("A process wasn't shutdown properly in a previous Gradle run. Killing process with PID $pid (Command line: $process)")
                pkill(pid)
                didKill = true
            }
            if (didKill) {
                //it might take a moment until file handles are released
                Thread.sleep(5000)
            }
        }
    }

    if (isCiServer) {
        clean.dependsOn killExistingProcessesStartedByGradle
        subprojects {
            tasks.all {
                mustRunAfter(killExistingProcessesStartedByGradle)
            }
        }
    }
}
